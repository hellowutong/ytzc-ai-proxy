{"version":3,"file":"chat-CXlrgbd5.js","sources":["../../src/stores/chat.ts"],"sourcesContent":["import { defineStore } from 'pinia'\nimport { ref } from 'vue'\nimport type { Conversation, Message } from '@/types'\nimport { useModelStore } from './models'\n\nexport const useChatStore = defineStore('chat', () => {\n  // State\n  const conversations = ref<Conversation[]>([])\n  const currentConversation = ref<Conversation | null>(null)\n  const isStreaming = ref(false)\n  const settings = ref({\n    temperature: 0.7,\n    max_tokens: 2000,\n    stream: true,\n    knowledge_enabled: true,\n    web_search_enabled: false,\n    dark_theme: true,\n    code_highlight: true,\n    show_thinking: false\n  })\n\n  // Actions\n  async function fetchConversations() {\n    try {\n      const response = await fetch('/admin/ai/v1/conversations')\n      const result = await response.json()\n      if (result.code === 200) {\n        // 去除重复ID的对话\n        const seenIds = new Set<string>()\n        const uniqueConversations = result.data.items.filter((conv: Conversation) => {\n          if (seenIds.has(conv.id)) {\n            console.warn('去除重复对话:', conv.id)\n            return false\n          }\n          seenIds.add(conv.id)\n          return true\n        })\n        \n        // 保存当前对话ID\n        const currentId = currentConversation.value?.id\n        \n        // 更新对话列表\n        conversations.value = uniqueConversations\n        \n        // 如果之前有当前对话，在新列表中重新找到它\n        if (currentId && currentConversation.value) {\n          const found = conversations.value.find(c => c.id === currentId)\n          if (found) {\n            currentConversation.value = found\n          } else {\n            // 如果没找到，清空当前对话（说明已被删除）\n            currentConversation.value = null\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Failed to fetch conversations:', error)\n    }\n  }\n\n  async function createConversation(model: string) {\n    try {\n      // 先创建后端对话\n      const response = await fetch('/admin/ai/v1/conversations', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ model })\n      })\n      const result = await response.json()\n      \n      if (result.code === 200) {\n        // 检查是否已存在相同ID的对话\n        const existingIndex = conversations.value.findIndex(\n          c => c.id === result.data.id\n        )\n        \n        if (existingIndex !== -1) {\n          // 已存在，直接使用已有对话，不创建新的\n          currentConversation.value = conversations.value[existingIndex]\n          return conversations.value[existingIndex]\n        }\n        \n        // 创建新对话\n        const newConversation: Conversation = {\n          id: result.data.id,\n          model,\n          messages: [],\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString()\n        }\n        conversations.value.unshift(newConversation)\n        currentConversation.value = newConversation\n        return newConversation\n      }\n    } catch (error) {\n      console.error('Failed to create conversation:', error)\n    }\n    return null\n  }\n\n  function setCurrentConversation(conversation: Conversation | null) {\n    currentConversation.value = conversation\n  }\n\n  async function sendMessage(content: string, model: string) {\n    // 注意：createConversation 应该由调用方在发送消息前确保调用\n    // 这里不再自动创建对话，避免重复创建\n\n    const userMessage: Message = {\n      role: 'user',\n      content,\n      timestamp: new Date().toISOString()\n    }\n\n    currentConversation.value?.messages.push(userMessage)\n\n    try {\n      isStreaming.value = true\n\n      // 获取当前模型的 proxy_key 用于认证\n      const modelStore = useModelStore()\n      const currentVm = modelStore.models.find(m => m.name === model)\n      const proxyKey = currentVm?.proxy_key || ''\n\n      const response = await fetch('/proxy/ai/v1/chat/completions', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${proxyKey}`\n        },\n        body: JSON.stringify({\n          model,\n          messages: currentConversation.value?.messages || [],\n          conversation_id: currentConversation.value?.id || null,\n          temperature: settings.value.temperature,\n          max_tokens: settings.value.max_tokens,\n          // 强制使用非流式（后端已统一为非流式响应）\n          // stream: settings.value.stream\n        })\n      })\n\n      // 检查Content-Type判断响应格式\n      const contentType = response.headers.get('content-type') || ''\n      const isJsonResponse = contentType.includes('application/json')\n\n      if (isJsonResponse) {\n        // 非流式响应 - 解析JSON\n        const result = await response.json()\n\n        // 检查是否是错误响应\n        if (result.error) {\n          const errorMessage: Message = {\n            role: 'assistant',\n            content: result.error.message || '抱歉，处理您的请求时出现了错误。',\n            timestamp: new Date().toISOString()\n          }\n          currentConversation.value?.messages.push(errorMessage)\n        } else {\n          // 正常响应\n          const assistantMessage: Message = {\n            role: 'assistant',\n            content: result.choices?.[0]?.message?.content || '',\n            timestamp: new Date().toISOString()\n          }\n          currentConversation.value?.messages.push(assistantMessage)\n        }\n      } else {\n        // 流式响应 (SSE) - 兼容旧版行为\n        const reader = response.body?.getReader()\n        const decoder = new TextDecoder()\n        let assistantContent = ''\n\n        const assistantMessage: Message = {\n          role: 'assistant',\n          content: '',\n          timestamp: new Date().toISOString()\n        }\n        currentConversation.value?.messages.push(assistantMessage)\n\n        while (reader) {\n          const { done, value } = await reader.read()\n          if (done) break\n\n          const chunk = decoder.decode(value)\n          const lines = chunk.split('\\n')\n\n          for (const line of lines) {\n            if (line.startsWith('data: ')) {\n              const data = line.slice(6)\n              if (data === '[DONE]') continue\n\n              try {\n                const parsed = JSON.parse(data)\n                const delta = parsed.choices?.[0]?.delta?.content\n                if (delta) {\n                  assistantContent += delta\n                  assistantMessage.content = assistantContent\n                }\n              } catch (e) {\n                // Ignore parse errors\n              }\n            }\n          }\n        }\n      }\n\n      if (currentConversation.value) {\n        currentConversation.value.updated_at = new Date().toISOString()\n      }\n\n      // 刷新模型数据以获取最新的 current 值（关键词切换后需要更新显示）\n      await modelStore.fetchModels()\n\n    } catch (error) {\n      console.error('Failed to send message:', error)\n      // 添加错误消息到对话\n      const errorMessage: Message = {\n        role: 'assistant',\n        content: '抱歉，发生了错误，请稍后重试。',\n        timestamp: new Date().toISOString()\n      }\n      currentConversation.value?.messages.push(errorMessage)\n    } finally {\n      isStreaming.value = false\n    }\n  }\n\n  async function saveConversation(conversation: Conversation | null) {\n    if (!conversation) return\n    \n    try {\n      // 确保对话有ID\n      if (!conversation.id) {\n        console.error('尝试保存没有ID的对话')\n        return\n      }\n      \n      const response = await fetch(`/admin/ai/v1/conversations/${conversation.id}`, {\n        method: 'PUT',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          messages: conversation.messages,\n          updated_at: conversation.updated_at\n        })\n      })\n      \n      // 如果405或404错误，静默处理（可能是旧版本后端）\n      if (!response.ok) {\n        console.warn(`保存对话失败: ${response.status}`)\n        return\n      }\n      \n      const result = await response.json()\n      if (result.code === 200) {\n        console.log('对话保存成功')\n        // 不自动刷新对话列表，避免竞态条件和引用丢失\n        // 只更新本地时间戳\n        if (currentConversation.value) {\n          currentConversation.value.updated_at = new Date().toISOString()\n        }\n      }\n    } catch (error) {\n      // 静默处理保存失败，不显示错误给用户\n      console.warn('保存对话失败:', error)\n    }\n  }\n\n  function stopStreaming() {\n    isStreaming.value = false\n  }\n\n  function updateSettings(newSettings: Partial<typeof settings.value>) {\n    settings.value = { ...settings.value, ...newSettings }\n  }\n\n  function clearCurrentConversation() {\n    if (currentConversation.value) {\n      currentConversation.value.messages = []\n    }\n  }\n\n  return {\n    conversations,\n    currentConversation,\n    isStreaming,\n    settings,\n    fetchConversations,\n    createConversation,\n    setCurrentConversation,\n    sendMessage,\n    saveConversation,\n    stopStreaming,\n    updateSettings,\n    clearCurrentConversation\n  }\n})\n"],"names":["useChatStore","defineStore","conversations","ref","currentConversation","isStreaming","settings","fetchConversations","result","seenIds","uniqueConversations","conv","currentId","_a","found","c","error","createConversation","model","existingIndex","newConversation","setCurrentConversation","conversation","sendMessage","content","userMessage","modelStore","useModelStore","currentVm","m","proxyKey","response","_b","_c","errorMessage","_d","assistantMessage","_g","_f","_e","_h","reader","_i","decoder","assistantContent","_j","done","value","lines","line","data","delta","_m","_l","_k","_n","saveConversation","stopStreaming","updateSettings","newSettings","clearCurrentConversation"],"mappings":"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"}
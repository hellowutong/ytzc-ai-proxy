# WebChat BUG 测试案例

## BUG 1: 关键词切换返回消息问题

### 测试案例 1.1: 纯关键词切换（@大哥）

**前置条件**:
- config.yml 中已配置关键词路由：
  ```yaml
  routing:
    keywords:
      enable: true
      rules:
      - pattern: '@大哥'
        target: big
  ```

**测试步骤**:
1. 打开 WebChat 页面
2. 选择模型 demo1
3. 在输入框输入："@大哥"
4. 点击发送

**期望结果**:
- 后端日志显示："关键词匹配: @大哥 -> big"
- **不显示任何AI回复消息**
- 可选：显示提示"已切换到大模型"
- 当前对话的模型类型变为 big

**实际结果**（修复前）:
- 会返回AI生成的响应消息

**通过标准**:
- [ ] 不调用LLM
- [ ] 不返回消息给用户
- [ ] 模型切换成功

---

### 测试案例 1.2: 纯关键词切换（@小弟）

**测试步骤**:
1. 打开 WebChat 页面
2. 选择模型 demo1
3. 在输入框输入："@小弟"
4. 点击发送

**期望结果**:
- 后端日志显示："关键词匹配: @小弟 -> small"
- **不显示任何AI回复消息**
- 当前对话的模型类型变为 small

**通过标准**:
- [ ] 不调用LLM
- [ ] 不返回消息给用户
- [ ] 模型切换成功

---

### 测试案例 1.3: 关键词+内容（正常对话）

**测试步骤**:
1. 打开 WebChat 页面
2. 选择模型 demo1
3. 在输入框输入："@大哥 你好"
4. 点击发送

**期望结果**:
- 后端日志显示："关键词匹配: @大哥 -> big"
- 后端日志显示："消息替换: '@大哥' -> ''"
- 发送给LLM的消息是："你好"
- **返回AI生成的响应消息**

**通过标准**:
- [ ] 调用LLM
- [ ] 返回AI响应
- [ ] 关键词已从消息中移除

---

### 测试案例 1.4: 无关键词（正常对话）

**测试步骤**:
1. 打开 WebChat 页面
2. 选择模型 demo1
3. 在输入框输入："你好"
4. 点击发送

**期望结果**:
- 不触发关键词匹配
- 使用默认路由决策
- 返回AI生成的响应消息

**通过标准**:
- [ ] 正常对话流程
- [ ] 返回AI响应

---

## BUG 2: 对话内容丢失问题

### 测试案例 2.1: 新建对话后内容保存

**测试步骤**:
1. 打开 WebChat 页面
2. 点击"新建对话"
3. 选择模型 demo1
4. 发送消息："第一条消息"
5. 等待AI响应

**验证点**:
- 检查 MongoDB conversations 集合
- 确认消息已保存到数据库

**期望结果**:
```json
{
  "_id": "conversation-id",
  "messages": [
    {"role": "user", "content": "第一条消息"},
    {"role": "assistant", "content": "AI响应内容"}
  ]
}
```

**通过标准**:
- [ ] 用户消息已保存
- [ ] 助手消息已保存

---

### 测试案例 2.2: 关闭页面后重新加载

**前置条件**:
- 已完成测试案例 2.1

**测试步骤**:
1. 点击"关闭页面"按钮
2. 从左侧菜单点击"WebChat测试"
3. 在历史对话列表中点击刚才的对话

**期望结果**:
- 对话内容区域显示之前的消息：
  - 用户："第一条消息"
  - 助手：AI响应内容

**实际结果**（修复前）:
- 对话内容区域为空

**通过标准**:
- [ ] 正确加载历史消息
- [ ] 消息顺序正确
- [ ] 消息内容完整

---

### 测试案例 2.3: 多轮对话保存

**测试步骤**:
1. 打开 WebChat 页面
2. 点击"新建对话"
3. 选择模型 demo1
4. 发送消息1："你好"
5. 等待AI响应1
6. 发送消息2："再试一次"
7. 等待AI响应2
8. 关闭页面
9. 重新打开 WebChat
10. 点击该对话

**期望结果**:
- 显示所有4条消息：
  1. 用户："你好"
  2. 助手：响应1
  3. 用户："再试一次"
  4. 助手：响应2

**通过标准**:
- [ ] 所有消息都正确显示
- [ ] 消息顺序正确

---

### 测试案例 2.4: 多个对话切换

**测试步骤**:
1. 新建对话A，发送消息"对话A的消息"
2. 新建对话B，发送消息"对话B的消息"
3. 关闭页面
4. 重新打开 WebChat
5. 点击对话A
6. 点击对话B
7. 再次点击对话A

**期望结果**:
- 点击对话A时，显示"对话A的消息"
- 点击对话B时，显示"对话B的消息"
- 切换时内容不混淆

**通过标准**:
- [ ] 每个对话显示正确内容
- [ ] 切换时内容不丢失

---

## 自动化测试脚本

### Python测试脚本（后端API测试）

```python
import requests
import json

def test_keyword_switch():
    """测试关键词切换"""
    url = "http://localhost:8000/proxy/ai/v1/chat/completions"
    
    # 测试纯关键词
    response = requests.post(url, json={
        "model": "demo1",
        "messages": [{"role": "user", "content": "@大哥"}]
    }, headers={"Authorization": "Bearer sk-xxxx"})
    
    result = response.json()
    
    # 验证：应该返回空响应或切换提示
    assert result["choices"][0]["message"]["content"] == "", "纯关键词不应该返回AI消息"
    assert result["metadata"]["model_type"] == "big", "应该切换到大模型"
    
    print("✅ 测试通过：纯关键词切换")

def test_conversation_save_and_load():
    """测试对话保存和加载"""
    base_url = "http://localhost:8000"
    
    # 1. 创建对话
    response = requests.post(f"{base_url}/admin/ai/v1/conversations", json={
        "model": "demo1"
    })
    conv_id = response.json()["data"]["id"]
    
    # 2. 更新消息
    requests.put(f"{base_url}/admin/ai/v1/conversations/{conv_id}", json={
        "messages": [
            {"role": "user", "content": "测试消息", "timestamp": "2026-01-01T00:00:00"}
        ],
        "updated_at": "2026-01-01T00:00:00"
    })
    
    # 3. 获取对话详情
    response = requests.get(f"{base_url}/admin/ai/v1/conversations/{conv_id}")
    result = response.json()
    
    # 验证
    assert len(result["data"]["messages"]) == 1, "消息应该被保存"
    assert result["data"]["messages"][0]["content"] == "测试消息", "消息内容正确"
    
    print("✅ 测试通过：对话保存和加载")

if __name__ == "__main__":
    test_keyword_switch()
    test_conversation_save_and_load()
```

---

## BUG 3: 对话重复问题

### 测试案例 3.1: 删除所有对话后重新提问

**前置条件**:
- config.yml 中已配置关键词路由（如需要）
- MongoDB 中有对话数据（可选项）

**测试步骤**:
1. 打开 WebChat 页面 (http://localhost:80/proxy/chat)
2. 如果左侧有对话，删除所有对话
3. 在输入框输入："测试对话重复问题"
4. 点击发送
5. 等待AI响应
6. 点击"关闭页面"按钮
7. 从左侧菜单点击"WebChat测试"
8. 观察左侧对话列表

**期望结果**:
- 左侧对话列表显示 **1个对话**
- 点击该对话，消息内容正确显示

**实际结果**（修复前）:
- 左侧对话列表显示 **2个对话**（重复创建）

**通过标准**:
- [ ] 对话列表只显示1个对话
- [ ] 对话内容正确
- [ ] 没有重复对话

---

### 测试案例 3.2: 删除单个对话后重新提问

**前置条件**:
- 已有至少1个对话

**测试步骤**:
1. 打开 WebChat 页面
2. 左侧对话列表中有1个或多个对话
3. 点击某个对话的删除按钮
4. 等待删除成功
5. 在输入框输入："测试删除后提问"
6. 点击发送
7. 等待AI响应
8. 关闭页面
9. 重新打开WebChat
10. 观察左侧对话列表

**期望结果**:
- 左侧对话列表显示正确数量的对话（原有数量-1+1 = 原有数量）
- 没有重复对话

**实际结果**（修复前）:
- 可能显示重复对话

**通过标准**:
- [ ] 对话数量正确
- [ ] 没有重复对话
- [ ] 对话内容正确

---

### 测试案例 3.3: 新建对话按钮测试

**测试步骤**:
1. 打开 WebChat 页面
2. 点击"新建对话"按钮
3. 观察左侧对话列表
4. 输入："测试新建对话按钮"
5. 点击发送
6. 等待AI响应
7. 关闭页面
8. 重新打开WebChat
9. 观察左侧对话列表

**期望结果**:
- 只显示1个对话
- 对话内容正确

**通过标准**:
- [ ] 没有重复对话
- [ ] 对话内容正确

---

## BUG 分析与修复计划

### BUG 3 分析：对话重复问题

**可能原因1: 前端状态管理问题**
- `conversations` 数组和 `currentConversation` 状态不同步
- 删除对话时只删除了前端数组中的元素，但没有同步到后端
- 重新获取对话列表时，旧的对话数据被重新加载

**可能原因2: 后端返回重复数据**
- MongoDB 查询返回重复数据
- 分页或排序问题导致数据重复

**可能原因3: 对话创建逻辑问题**
- 每次发送消息时都创建新对话
- 但保存消息时没有正确关联到已有对话

### 修复策略

1. **检查前端对话列表获取逻辑**
   - 确保 `fetchConversations` 正确获取对话列表
   - 确保没有重复添加对话到列表

2. **检查对话删除逻辑**
   - 删除后立即刷新对话列表
   - 确保删除操作成功后清除相关缓存

3. **检查对话创建逻辑**
   - 确保只在没有当前对话时才创建新对话
   - 确保创建对话后正确更新状态

4. **前后端同步**
   - 确保前端状态和后端数据一致
   - 添加适当的错误处理和重试机制

---

## 测试执行计划

1. **BUG 1 测试** - 测试关键词功能
   - 执行测试案例 1.1 - 1.4
   - 验证纯关键词不返回消息

2. **BUG 2 测试** - 测试对话持久化
   - 执行测试案例 2.1 - 2.4
   - 验证对话内容正确保存和加载

3. **BUG 3 测试** - 测试对话重复问题
   - 执行测试案例 3.1 - 3.3
   - 验证对话列表没有重复
